\chapter{Introduction}%
\label{ch:intro}%

%\nv{%
%In this section, I'll try to portray my ``elevator pitch''.
%
%\textbf{Pitch:}
%\begin{enumerate}
%    \item\label{item:pitch1} What is the problem this thesis is trying to solve?
%        \begin{itemize}
%            \item The hardware and system architecture is getting more powerful.
%            \item This increases the complexity of the designed system and increases the error probability.
%            \item Especially since more and more junior developers can use this powerful and complicated hardware for their designs.
%        \end{itemize}
%    \item Why is the problem an important one to analyse?
%        \begin{itemize}
%            \item This can introduce huge risks in safety critical systems, risking lives and damage to humans
%            \item Can cause major damage on infrastructure and commercial systems
%            \item Security issues are introduced, leaking private data
%        \end{itemize}
%    \item Give a positive and bold statement of what this thesis is doing.
%        \begin{itemize}
%            \item We present novel theoretical and practically applicable analytical tools to help analyse fault-prone systems
%            \item We focus on making these tools easy to use, lowering the threshold for developers to use them in everyday life
%            \item \textbf{If nothing else is remembered from the thesis, this should be it.}
%        \end{itemize}
%    \item The consequences of the thesis (preferably ``solve'' the problem in~\ref{item:pitch1})
%        \begin{itemize}
%            \item By applying the tools presented in this thesis to embedded real-time control systems, we can identify and mitigate a lot of trivial bugs and errors that occur.
%        \end{itemize}
%\end{enumerate}
%}%
%
%
%\nv{%
%\textbf{The What:}
%\begin{itemize}
%    \item Connectivity, Distributed systems, NCS, IoT, Wireless
%    \item Communication hiccups
%    \item packet drops
%    \item deadline misses
%\end{itemize}
%}%
%
%\nv{%
%\textbf{The why:}
%\begin{itemize}
%    \item Huge costs, damages
%    \item Safety
%    \item Security
%    \item Paper by~\cite{Akesson:2020}
%\end{itemize}
%}%
%
%\nv{%
%\textbf{The Statement:}
%\begin{itemize}
%    \item Theoretical and practical tools for analysing and synthesising
%        fault-tolerant controllers, with significant performance gains.
%    \item Lowering the entry-level knowledge for applying the tools to real
%        processes.
%\end{itemize}
%}%
%
%\nv{%
%\textbf{The Consequences:}
%\begin{itemize}
%    \item Decoupling and clarifying real-time and control theoretical models.
%    \item Making them more accessible to a broader class of practitioners.
%\end{itemize}
%}%

%%% WHAT
% Introduction to digitalisation
Entering the digital age has forever changed how we interact with the world and how it interacts with us.
Unlike only 20 years ago, from the moment we wake up in the morning till the moment we close our eyes at night, we interact with advanced computer systems.
Our cellphones, work computers, and even our cars going contain many computational devices, performing everything from menial tasks, such as checking the weather and accessing mail clients, to safety critical tasks, such as the car's ABS breaks and most of the engine's functionality.
To put the digital growth rate in perspective, the semiconductor\footnote{Semiconductors are components constituting the foundation of generally \emph{all} electronic devices.} market share has more than quadrupled over the last 20 years~\cite{statista:2022}.

% The hardware architecture is getting more powerful and cheaper to use
Not only is the number of computational devices increasing, but their independent capabilities, functionalities, and complexities are growing steadily, all while the cost to buy and manufacture them has become cheaper.
Obviously, the increased efficiency and reduced cost opened up new businesses and domains, in particular within the IT-domain, whilst also consolidating and automating preexisting industry.
Integrating digital components and software solutions is nowadays the norm rather than the exception; this does not come as a surprise, considering that automating and simplifying the decision making and data collection yield both economical and safety benefits.
Generally, integrating software into any domain help monitor system safety, log and transmit important data, orchestrate the execution of different components, and remotely micromanage system updates.
Subsequently, software integration is a powerful tool that improve both efficiency and increase revenue, when everything behaves as intended.

\question{Should I explain what type of issues I'm working with already here?}{No, I think the transition to your work can come a little later. Right now, you are still missing some of the basic building blocks to the story, in my opinion.}

% The complexity and reduced prices increase error surfaces
Interconnecting multiple systems is, however, not a trivial task.
When the systems are getting increasingly more complex, the surface for possible errors is also growing.
In addition to the components' individual faults, after connecting two components together, additional problems can be encountered; for instance, problems with the coupling of the components' or new problems in the individual components.
Imagine a motorbike; it can experience all the same problems that a normal bike can encounter (punctured tire, loose chain, etc.), but it can also experience issues from connecting the bike together with a motor (electric clutch, battery, sensor networks, etc.). \mm{I like the example of the motorbike, but I think the language and the framing is a bit colloquial here. I think what I react to is the ``imagine'' bit. This sentence also feels too long.}
Similarly to the motorbike, systems relying on the interconnection of computational devices and digital components can experience complex coupling issues.
For example, data transmissions can easily be delayed or stall indefinitely if data is lost, a computer's orchestrator can get overloaded, and systems with remote updates have the potential to break every time a new patch is installed.
These problems are neither easy to detect nor troubleshoot; particularly since their origin can be obfuscated by complex software and hardware interconnections.

%%% WHY
% Costs
The effects of such errors can be extremely expensive and in the worst case cause companies to lose billions of dollars.
Typically the outcome of system faults is that the normal operation of the device (or machine) is degraded.
The degradation can over time accumulate and either wear down the device or affect the end product.
Obviously, if it is possible to extend a device's lifetime by fixing software-induced errors, a lot of money could be gained. \mm{I don't like the passive form in this sentence, in particular because the thesis is then about software-induced errors (in a way). I would expect you to ``own'' the topic here.}
Furthermore, if the end product is inferior to the promised product, the consumers would go elsewhere --- no matter whether the product is a service, such as cloud storage, or a physical product, such as a cellphone.

% Safety and security
Arguably more important than the economic consequences are the risks to personal safety, security, and privacy.
One of the modern era's most famous examples are the Boeing's 737 MAX\footnote{\url{https://en.wikipedia.org/wiki/Boeing_737_MAX_groundings}} crashes, killing 346 people in two subsequent crashes.
The crashes were caused by erroneous sensor readings being misinterpreted by the flight control system, resulting in the planes nosediving into the ground.
Another relevant (although less lethal) example is the famous malicious Stuxnet worm\footnote{\url{https://en.wikipedia.org/wiki/Stuxnet}}.
Stuxnet infiltrated the system controlling the gas-centrifuges in multiple Iranian nuclear plants, significantly damaging them whilst also collecting critical information. 

Generally it is impossible to guarantee that today's complex computer systems are absolutely safe, secure, and performs according to specifications under all conditions.
Additionally, testing for all possible future problems is expensive and time consuming at best and infeasible in practice.
It is therefore crucial to develop easy-to-use, powerful tools to simplify the analysis of both the systems' performance and safety properties.

%%% STATEMENT & CONSEQUENCES
% Concluding paragraph summarising what the thesis is tackling and what the consequences of this might be
It is the purpose of this thesis to provide tools and methods for analysing systems experiencing faults. \mm{I would also flip this into its \emph{active} counterpart: The purpose of this thesis is...}
In particular, the focus is to analyse software integrated systems where the faults are occurring in the interconnection between software and hardware.
By treating accessibility, clarity, and generalisability as first-class citizens we aim to lower the threshold for using the powerful tools provided.

\question{Add something more to the end here? Maybe why this thesis help solve the problems stated in 3rd and 4th paragraph?}{I think you want to add something more here, yes. My take would be to add something quite technical at this point, that will be explained later. And then add a sentence that says that in the following subsection you will delve into the basic components of the technical sentence that you wrote just above. Basically, tell me why I should read the list of things below, otherwise I am not sure why I should be interested.}



\section{Real-Time Control Systems}%
\label{sec:intro:rts}%
%
\question{Should I add sensor and actuator blocks to the plant in Figure~\ref{fig:high-level-abstraction}?}{I'd say not needed. The arrows are enough for me. You could have them as small boxes near the airplane box if you want, but I don't think that would add very much to the clarity of the figure.}
%
Fundamentally all systems today contain a certain level of automation, whether it is automatic heat control in buildings or memory allocation in the cloud for storing photos.
Abstracting a system to a common mathematical language and making it behave according to predefined specifications is called \emph{automatic control}. \mm{I think I would try to restrict to cyber-physical systems (or control systems, or systems that interact with the environment). So far you are talking about ``all systems'' and I can imagine for example a travel booking website as a ``system''. I am not sure I would say that abstracting such a system (that still is a valid action, or thing to do) is called automatic control.}
Common among all automatic control systems (\emph{control systems} for short) is that they employ \emph{feedback}, i.e., data collected from the system is routed back and used in the decision mechanisms to control the system.
As an example, consider the temperature control in a room; if the actual temperature is known, it can be used (fed back) to determine whether the heating should be turned up or down to meet the desired temperature.
A specific class of control systems are the \emph{real-time control systems}, which are defined by guaranteeing the timely execution of software in the control system.
The word ``real-time'' is often used synonymously with ``being very fast'', however, a more accurate synonym might be ``timely''. \mm{The phrasing is a bit confusing -- I would write something like the following: ``A common misconception is that real-time systems are inherently very fast. However, the definition only relate the timing of the system to a precise notion of correctness.'' and then connect it to the following sentence.}
In fact, a real-time system is not required to be fast, but it is required to guarantee that predefined temporal constraints are met.
These constraints are generally enforced by a \emph{real-time operating system} (RTOS).

A high-level abstraction of a real-time control system is depicted in Figure~\ref{fig:high-level-abstraction}.
Next, the individual components seen in the figure are introduced. 
%
\begin{figure}[t]
    \centering
    \input{\figdir/high-level-abstraction}%
    \caption{\fix{Maybe change font? Change ``HW Interfaces''?}.}%
    \label{fig:high-level-abstraction}%
\end{figure}

\subsubsection{Plant}% Plant, sensors, HW interface
%
The right part of the figure depict the process we are trying to control (denoted the \emph{plant}).
This could be anything from an airplane's taxiing system, indoor heating systems, or the load on a server in a data centre.
In this and following chapters, the taxiing system will be used as a recurring example to illustrate the different concepts.
The arrows going to and from the plant indicate the flow of data; actuation data goes into the plant and sensor data is collected on the plant.
Actuation data refers to the commands sent to the components responsible for movement or change in the plant, i.e., the actuators.
Similarly, the sensor data is all information collected by the sensors, e.g., the rotational velocity of the wheel or the friction between the wheel and the ground in the taxiing system.
These signals are transmitted via the hardware interfaces on the computational unit responsible for controlling the plant.
Historically, these signals were transmitted via wire, but in the last couple of decades wireless communication has become more common. \mm{You may need a reference for this sentence.}

\question{Should we add a ``hardware interface'' subsubsection that mention different communication protocols (CAN, TCP, UDP), signals, etc?}{I would only add a comment here, and mention some protocols/infrastructures (maybe even in a footnote, it is not so important for the narrative), without entering into details.}

\subsubsection{Hardware}% Hardware
%
Depending on the application, the hardware used to control the plant can be anything from a logic-based system (e.g., programmable logic controllers) to a general purpose computer (e.g., laptops or server systems).
We mainly refer to \emph{microcontrollers} (MCUs), i.e., small computers with integrated memory, computational processing units (CPUs), graphical processing units (GPUs), and programmable input/output peripherals (GPIOs) all on a single chip; however, we emphasise that the presented results are not bound to a specific hardware architecture.
It is also common to connect multiple levels of control hardware together.
For instance, having a high-level trajectory planner communicate with a low-level control structure whose objective is to enforce that the desired trajectory is followed, e.g., the taxiways on the airfield.
\question{Write something more about this, like distributed control?}{Yes. I think you want to state that depending on the hardware that is chosen the computer architecture can be distributed, and there could be for example sensors with their own MCUs, that execute some operations on the data before sending it to a controller etc.}

\subsubsection{Real-Time Operating System}% RTOS, Tasks, and control task
%
The defining characteristics of a real-time control system is that it relies on a real-time operating system to schedule and constraint the temporal execution of \emph{tasks}. \mm{I am not 100\% sure about this. There is certainly some aspect of task synchronisation and orchestration, but it does not have to be performed by a RTOS. I would tone it down saying that ``commonly'' control systems are implemented on top of RTOSs.}
All real-time applications can be structured as a set of tasks.
Each task is assigned a \emph{priority} (i.e., a value to describe how important the task is), a dedicated function to execute (e.g., compute a value, transmit data, or log data), and a \emph{deadline} before which the function is supposed to complete its execution.
Typically there exists more than one task executing in the RTOS.
To guarantee that each task is assigned the correct amount of processor time, a \emph{scheduler} is used to orchestrate the tasks' execution.
Specifically, the scheduler
\begin{enumerate*}[label = (\roman*)]
    \item swaps tasks in and out,
    \item wakes up tasks that are currently not executing but should start executing, and
    \item interrupt tasks that are currently executing when something with higher priority requires the processor.
\end{enumerate*}
The orchestration is based on a scheduling algorithm, where some of the most popular algorithms include: fixed-priority, earliest-deadline-first, and round-robin.
Additionally, the tasks are not supposed to have any information about the RTOS orchestration and it is thus the RTOS responsibility to ensure that the task has access to its own \emph{context}, i.e., the resources it requires. 
\question{Mention something about jobs and deadline overruns?}{You want to mention WCET first, and WCRT afterwards. And then in the next section, I would add at the end that the period is directly linked to control performance and hence one may want to select a period that is smaller than the WCRT on purpose, and accept that the control task may experience some overruns and hence miss some deadlines.}

\subsubsection{Controller}% Controller and Actuator
%
As can be seen in Figure~\ref{fig:high-level-abstraction}, we distinguish \emph{control tasks} from normal tasks.
From the perspective of the RTOS, there is no discernible difference between these tasks, however, programmatically there is. \mm{I would just remove this sentence and add in the sentence above ``we conceptually distinguish control tasks from normal tasks, even though for the RTOS such a difference does not exist.''}
The control tasks are all the tasks responsible for controlling the plant, while the normal tasks take care of everything else.
Taking the taxiing system as an example, the control tasks can be two tasks where one is controlling the velocity of the landing gear while the other is controlling its retraction mechanism.
Additionally, there are other tasks communicating sensor data (e.g., tire-pressure, temperature, etc.) to the aircraft's central computer.
As elaborated in Chapter~\ref{ch:background}, we partition the tasks in these two categories because we are specifically interested in analysing the control tasks' effect on the system when their temporal execution is unreliable. \mm{I would substitute ``system'' with ``physical system'' or anyway qualify it.}

\subsubsection{Clocks}% Clocks
%
\mm{I would put this subsubsection right after ``hardware'', to close the section with the ``controller'' and with the aim of the thesis (we are specifically interested in analysing the control tasks' effect...).}
There exists another discrepancy between the components of the real-time control system: the time quantisation.
The plant, hardware, and RTOS are most likely executing in different time scales, where the plant (at least in the taxiing example) is likely to execute in a continuous time scale while the hardware and RTOS are both executing in (different) discrete quanta.
Extremely simplified, the hardware contains a \emph{clock} that measures the progress of physical time in \emph{ticks} rather than seconds (like a wall-clock would).
For the hardware clock, these ticks are physical events (typically the oscillations of a crystal) occurring with a known frequency.
The RTOS clock is then based on the hardware clock; it reads the hardware clock at a frequency specified by the user and wraps it in a virtual layer to improve applicability. 
The granularity of the RTOS clock is thus quite coarse, which in turn introduces \emph{release jitter} and \emph{execution time variations} on the tasks.
Additionally, the inconsistencies between different clocks is a difficult problem and it has in fact warranted its own research domain, i.e., clock synchronisation.

\subsection{Timeliness}%
\label{sec:intro:timeliness}%
%
Executing a real-time control system is one thing, but executing it under suboptimal timing conditions is another.
As already mentioned, faults typically lead to reduced quality of the end product and can in the worst case be lethal.
However, ``timing faults'' is a huge oversimplification of a complex class of problems.
When analysing timing faults and irregularities it is thus important to properly define the fault type under analysis.
The following list include some of the most general timing irregularities analysed in literature.
%
\begin{itemize}
    \item \emph{Computational overruns} -- When there exists computational elements in the system, \note{i.e., something that takes the current state of the system and transforms it}, there is the possibility that it will not complete its execution, either on time or at all. % TODO: Skeptical about this statement
        Typically, this is connected to a real-time system if the computation has to complete before a predetermined \emph{deadline}.

    \item \emph{Time delays} -- Time delays might be some of the eldest timing problems analysed in the literature.
        Nowadays, time delays involve both internal time delays and input/output delays, i.e., respectively when the plant includes time delays or when the sensing, actuation, or control contains time delays. \question{Should I expand?}{Just a tiny bit more, I believe. I think you may want to add a couple of references here, and say that control theory has developed ways of dealing with time delays (I would cite Leonid Mirkin's work for example) and also that when these time delays are unpredictable and can cause real problems, control engineers typically design controllers that take into account the delays (and here I would cite some of Anton's work).}

    \item \emph{Jitter} -- The variations in time delay is called jitter. \mm{While I agree with you with the definition, I think a real-time system person will immediately think of release jitter and then might be a bit confused here. You may want to explicitly state at some point that for RTOSs one source of jitter is release jitter and define it (so that people will immediately understand that release jitter is a specialisation of what you mean).}
        For instance, when transmitting data over a network, if the latency (time delay) is constant in time, there is no jitter.
        Instead, if the latency varies over time (as it usually does), there exists jitter in the system.
        The jitter intensity depends on the size of the latency fluctuations.

    \item \emph{Communication losses} -- If data packets transmitted over a network are lost along their route or too delayed to be useful, they are considered \emph{lost}.
        Another case when the packets are dropped is when the network is shut down or overloaded, either by too much traffic or an attack.
        The packet loss can occur both on the way to and from the hardware.
\end{itemize}
%
Conceptually, it might be natural to view some of the timing irregularities as equivalent from a system perspective. \mm{You need a bit more explanation here -- I like the sentence but the meaning and implications at this point may not be clear unless you provide some additional details.}
However, the different models hold unique information about the system that does not necessarily overlap.
It is therefore crucial to analyse all the appropriate models for the specific systems.

This thesis specifically targets systems subject to computational overruns, and (to a minor extent) communication losses.
Of particular interest are the problems that occur in real-time control systems due to control tasks overrunning their corresponding deadlines.
It is convenient to blame computational overruns on poor system design and programming errors; however, even a flawless system design can experience overruns due to, for instance, cache memory misses~\addref{} or alpha-induced faults~\addref{}. \mm{If you add some statements about control performance above (and the fact that one may want to shorten the period of the controller, being aware that the period is smaller than the WCRT) then this connects really well with the sentence that you have just after.}
More commonly, it is known that the real-time control system's nominal performance is degraded if a design that completely avoids overruns is used.
Thus, with the awareness that it can cause transient faults, the control system engineers tolerate a few overruns when the control task's execution time is near its worst case, in order to improve the system's nominal performance.



\section{Outline}%
\label{sec:intro:outline}%
%
This thesis is a collection of papers and is divided into two parts.
The first part comprises the first three chapters and serves both as a summary and as an extension of the motivation for the research work.
The second part includes the papers that constitute the major scientific contribution of this thesis.

The first chapter presented a high-level introduction to the relevant concepts and problems.
Next, Chapter~\ref{ch:background} provide a rigorous presentation of the concepts that were loosely introduced in Chapter~\ref{ch:intro}.
In addition to the proper problem description, the chapter also outlines the relevant background and related work from both the real-time and control theoretical domains.
For each of the five papers constituting the main part of the thesis, Chapter~\ref{ch:contribution} contains a short summary of its content, a brief description of its scientific contribution, and the respective authors' individual contribution.
The thesis is finally concluded by Papers I-V. \mm{I would remove this sentence.}
