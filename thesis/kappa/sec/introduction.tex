\chapter{Introduction}%
\label{ch:intro}%

%\nv{%
%In this section, I'll try to portray my ``elevator pitch''.
%
%\textbf{Pitch:}
%\begin{enumerate}
%    \item\label{item:pitch1} What is the problem this thesis is trying to solve?
%        \begin{itemize}
%            \item The hardware and system architecture is getting more powerful.
%            \item This increases the complexity of the designed system and increases the error probability.
%            \item Especially since more and more junior developers can use this powerful and complicated hardware for their designs.
%        \end{itemize}
%    \item Why is the problem an important one to analyse?
%        \begin{itemize}
%            \item This can introduce huge risks in safety critical systems, risking lives and damage to humans
%            \item Can cause major damage on infrastructure and commercial systems
%            \item Security issues are introduced, leaking private data
%        \end{itemize}
%    \item Give a positive and bold statement of what this thesis is doing.
%        \begin{itemize}
%            \item We present novel theoretical and practically applicable analytical tools to help analyse fault-prone systems
%            \item We focus on making these tools easy to use, lowering the threshold for developers to use them in everyday life
%            \item \textbf{If nothing else is remembered from the thesis, this should be it.}
%        \end{itemize}
%    \item The consequences of the thesis (preferably ``solve'' the problem in~\ref{item:pitch1})
%        \begin{itemize}
%            \item By applying the tools presented in this thesis to embedded real-time control systems, we can identify and mitigate a lot of trivial bugs and errors that occur.
%        \end{itemize}
%\end{enumerate}
%}%
%
%
%\nv{%
%\textbf{The What:}
%\begin{itemize}
%    \item Connectivity, Distributed systems, NCS, IoT, Wireless
%    \item Communication hiccups
%    \item packet drops
%    \item deadline misses
%\end{itemize}
%}%
%
%\nv{%
%\textbf{The why:}
%\begin{itemize}
%    \item Huge costs, damages
%    \item Safety
%    \item Security
%    \item Paper by~\cite{Akesson:2020}
%\end{itemize}
%}%
%
%\nv{%
%\textbf{The Statement:}
%\begin{itemize}
%    \item Theoretical and practical tools for analysing and synthesising
%        fault-tolerant controllers, with significant performance gains.
%    \item Lowering the entry-level knowledge for applying the tools to real
%        processes.
%\end{itemize}
%}%
%
%\nv{%
%\textbf{The Consequences:}
%\begin{itemize}
%    \item Decoupling and clarifying real-time and control theoretical models.
%    \item Making them more accessible to a broader class of practitioners.
%\end{itemize}
%}%

%%% WHAT
% Introduction to digitalisation
Entering the digital age has forever changed how we interact with the world and how it interacts with us.
Unlike only 20 years ago, from the moment we wake up in the morning till the moment we close our eyes at night, we interact with advanced computer systems.
Our cellphones, work computers, and even our cars going contain many computational devices, performing everything from menial tasks, such as checking the weather and accessing mail clients, to safety critical tasks, such as the car's ABS breaks and most of the engine's functionality.
To put the digital growth rate in perspective, the semiconductor\footnote{Semiconductors are components constituting the foundation of generally \emph{all} electronic devices.} market share has more than quadrupled over the last 20 years~\cite{statista:2022}.

% The hardware architecture is getting more powerful and cheaper to use
Not only is the number of computational devices increasing, but their independent capabilities, functionalities, and complexities are growing steadily, all while the cost to buy and manufacture them has become cheaper.
Obviously, the increased efficiency and reduced cost opened up new businesses and domains, in particular within the IT-domain, whilst also consolidating and automating preexisting industry.
Integrating digital components and software solutions is nowadays the norm rather than the exception; this comes as no surprise, considering that automating and simplifying the decision making and data collection yield both economical and safety benefits.
Generally, integrating software into any domain help monitor system safety, log and transmit important data, orchestrate the execution of different components, and remotely micromanage system updates.
Subsequently, software integration is a powerful tool that improve both efficiency and increase revenue, when everything behaves as intended.

\question{Should I explain what type of issues I'm working with already here?}{}

% The complexity and reduced prices increase error surfaces
Interconnecting multiple systems is, however, not a trivial task.
When the systems are getting increasingly more complex, the surface for possible errors is also growing.
In addition to the components' individual faults, after connecting two components together, additional problems can be encountered; for instance, problems with the coupling of the components' or new problems in the individual components.
Imagine a motorbike; it can experience all the same problems that a normal bike can encounter (punctured tire, loose chain, etc.), but it can also experience issues from connecting the bike together with a motor (electric clutch, battery, sensor networks, etc.).
Similarly to the motorbike, systems relying on the interconnection of computational devices and digital components can experience complex coupling issues.
For example, data transmissions can easily be delayed or stall indefinitely if data is lost, a computer's orchestrator can get overloaded, and systems with remote updates have the potential to break every time a new patch is installed.
These problems are neither easy to detect nor troubleshoot; particularly since their origin can be obfuscated by complex software and hardware interconnections.

%%% WHY
% Costs
The effects of such errors can be extremely expensive and in the worst case cause companies to lose billions of dollars.
Typically the outcome of system faults is that the normal operation of the device (or machine) is degraded.
The degradation can over time accumulate and either wear down the device or affect the end product.
Obviously, if it is possible to extend a device's lifetime by fixing software-induced errors, a lot of money could be gained.
Furthermore, if the end product is inferior to the promised product, the consumers would go elsewhere --- no matter whether the product is a service, such as cloud storage, or a physical product, such as a cellphone.

% Safety and security
Arguably more important than the economic consequences are the risks to personal safety, security, and privacy.
One of the modern era's most famous examples are the Boeing's 737 MAX\footnote{\url{https://en.wikipedia.org/wiki/Boeing_737_MAX_groundings}} crashes, killing 346 people in two subsequent crashes; the crashes were caused by erroneous sensor readings being misinterpreted by the flight control system, resulting in the planes nosediving into the ground.
Another relevant (although less lethal) example is the famous malicious Stuxnet worm\footnote{\url{https://en.wikipedia.org/wiki/Stuxnet}}; it infiltrated the system controlling the gas-centrifuges in multiple Iranian nuclear plants, significantly damaging them whilst also collecting critical information. 
Generally it is impossible to guarantee that today's complex computer systems are absolutely safe, secure, and performs according to specifications under all conditions.
Additionally, testing for all possible future problems is expensive and time consuming at best and infeasible in practice.
It is therefore crucial to develop easy-to-use, powerful tools to simplify the analysis of both the systems' performance and safety properties.

%%% STATEMENT & CONSEQUENCES
% Concluding paragraph summarising what the thesis is tackling and what the consequences of this might be
It is the purpose of this thesis to provide tools and methods for analysing systems experiencing faults.
In particular, the focus is to analyse software integrated systems where the faults are occurring in the interconnection between software and hardware.
By treating accessibility, clarity, and generalisability as first-class citizens we aim to lower the threshold for using the powerful tools provided.

\question{Add something more to the end here? Maybe why this thesis help solve the problems stated in 3rd and 4th paragraph?}{}



\section{Real-Time Control Systems}%
\label{sec:intro:rts}%
%
\question{Should I add sensor and actuator blocks to the plant in Figure~\ref{fig:high-level-abstraction}?}{}
%
Fundamentally all systems today contain a certain level of automation, whether it is automatic heat control in buildings or memory allocation in the cloud for storing photos.
Abstracting a system to a common mathematical language and making it behave according to predefined specifications is called \emph{automatic control}.
Common among all automatic control systems (\emph{control systems} for short) is that they employ \emph{feedback}, i.e., data collected from the system is routed back and used in the decision mechanisms to control the system.
As an example, consider the temperature control in a room; if the actual temperature is known, it can be used (fed back) to determine whether the heating should be turned up or down to meet the desired temperature.
A specific class of control systems are the \emph{real-time control systems}, which are defined by guaranteeing the timely execution of software in the control system.
The word ``real-time'' is often used synonymously with ``being very fast'', however, a more accurate synonym might be ``timely''.
In fact, a real-time system is not required to be fast, but it is required to guarantee that predefined temporal constraints are met.
These constraints are generally enforced by a \emph{real-time operating system} (RTOS).

A high-level abstraction of a real-time control system is depicted in Figure~\ref{fig:high-level-abstraction}.
Next, the individual components seen in the figure are introduced. 
%
\begin{figure}[t]
    \centering
    \input{\figdir/high-level-abstraction}%
    \caption{\fix{Maybe change font? Change ``HW Interfaces''?}.}%
    \label{fig:high-level-abstraction}%
\end{figure}

\subsubsection{Plant}% Plant, sensors, HW interface
%
The right part of the figure depict the process we are trying to control (denoted the \emph{plant}).
This could be anything from an airplane's taxiing system, indoor heating systems, or the load on a server in a data centre.
In this and following chapters, the taxiing system will be used as a recurring example to illustrate the different concepts.
The arrows going to and from the plant indicate the flow of data; actuation data goes into the plant and sensor data is collected on the plant.
Actuation data refers to the commands sent to the components responsible for movement or change in the plant, i.e., the actuators.
Similarly, the sensor data is all information collected by the sensors, e.g., the rotational velocity of the wheel or the friction between the wheel and the ground in the taxiing system.
These signals are transmitted via the hardware interfaces on the computational unit responsible for controlling the plant.
Historically, these signals were transmitted via wire, but in the last couple of decades wireless communication has become more common.

\question{Should we add a ``hardware interface'' subsubsection that mention different communication protocols (CAN, TCP, UDP), signals, etc?}{}

\subsubsection{Hardware}% Hardware
%
Depending on the application, the hardware used to control the plant can be anything from a logic-based system (e.g., programmable logic controllers) to a general purpose computer (e.g., laptops or server systems).
We will mainly refer to the hardware as a \emph{microcontroller} (MCU), i.e., a small computer with integrated memory, computational processing unit (CPU), graphical processing units (GPU), and programmable input/output peripherals (GPIO) all on a single chip; however, we emphasise that the presented results do not discriminate between hardware architectures.
It is also common to connect multiple levels of control hardware together.
For instance, having a high-level trajectory planner communicate with a low-level control structure whose objective is to enforce that the desired trajectory is followed, e.g., the taxiways on the airfield.
\question{Write something more about this, like distributed control?}{}

\subsubsection{Real-Time Operating System}% RTOS, Tasks, and control task
%
The defining characteristics of a real-time control system is that it relies on a real-time operating system to schedule and constraint the temporal execution of \emph{tasks}.
All real-time applications can be structured as a set of tasks.
Each task is assigned a \emph{priority} (i.e., a value to describe how important it is), a dedicated function to execute (e.g., compute a value, transmit data, or log data), and a \emph{deadline} before which the function is supposed to complete its execution.
Typically there exists more than one task executing in the RTOS.
To guarantee that each task is assigned the correct amount of processor time, a \emph{scheduler} is used to orchestrate the tasks' execution.
Specifically, the scheduler
\begin{enumerate*}[label = (\roman*)]
    \item swaps tasks in and out,
    \item wakes up tasks that are currently not executing but should start executing, and
    \item interrupt tasks that are currently executing when something with higher priority requires the processor.
\end{enumerate*}
The orchestration is based on a scheduling algorithm, where some of the most popular algorithms include: fixed-priority, earliest-deadline-first, and round-robin.
Additionally, the tasks are not supposed to have any information about the RTOS orchestration and it is thus the RTOS responsibility to ensure that the task has access to its own \emph{context}, i.e., the resources it requires. 
\question{Mention something about jobs and deadline overruns?}{}

\subsubsection{Controller}% Controller and Actuator
%
As can be seen in Figure~\ref{fig:high-level-abstraction}, we distinguish \emph{control tasks} from normal tasks.
From the perspective of the RTOS, there is no discernible difference between these tasks, however, programmatically there is.
The control tasks are all the tasks responsible for controlling the plant, while the normal tasks take care of everything else.
Taking the taxiing system as an example, the control tasks can be two tasks where one is controlling the velocity of the landing gear while the other is controlling its retraction mechanism.
Additionally, there are other tasks communicating the sensor data (e.g., tire-pressure, temperature, etc.) to the aircraft's central computer.
The tasks are divided into two categories because we are specifically interested in analysing the control tasks' effect on the system when their temporal execution is unreliable; this will be elaborated in Chapter~\ref{ch:background}.

\subsubsection{Clocks}% Clocks
%
There exists another discrepancy between the components of the real-time control system: the time quantisation.
The plant, hardware, and RTOS are most likely executing in different time scales, where the plant (at least in the taxiing example) is likely to execute in a continuous time scale while the hardware and RTOS are both executing in (different) discrete quanta.
Extremely simplified, the hardware contains a \emph{clock} that measures the progress of physical time in \emph{ticks} rather than seconds (like a wall-clock would).
For the hardware clock, these ticks are physical events (typically the oscillations of a crystal) occurring with a known frequency.
The RTOS clock is then based on the hardware clock; it reads the hardware clock at a frequency specified by the user and wraps it in a virtual layer to improve applicability. 
The granularity of the RTOS clock is thus quite coarse, which in turn introduces \emph{release jitter} and \emph{execution time variations} on the tasks.
Additionally, the inconsistencies between different clocks is a difficult problem and it has in fact warranted its own research domain, i.e., clock synchronisation.

\subsection{Timeliness}%
\label{sec:intro:timeliness}%
%
Executing a real-time control system is one thing, but executing it under suboptimal timing conditions is another.
As already mentioned, faults typically lead to reduced quality of the end product and can in the worst case be lethal.
However, ``timing faults'' is a huge oversimplification of a complex class of problems.
When analysing timing faults and irregularities it is thus important to properly define the fault type under analysis.
The following list include some of the most general timing irregularities analysed in literature.
%
\begin{itemize}
    \item \emph{Computational overruns} -- When there exists computational elements in the system, \note{i.e., something that takes the current state of the system and transforms it}, there is the possibility that it will not complete its execution, either on time or at all. % TODO: Skeptical about this statement
        Typically, this is connected to a real-time system if the computation has to complete before a predetermined \emph{deadline}.

    \item \emph{Time delays} -- Time delays might be some of the eldest timing problems analysed in the literature.
        Nowadays, time delays involve both internal time delays and input/output delays, i.e., respectively when the plant includes time delays or when the sensing, actuation, or control contains time delays. \question{Should I expand?}{}

    \item \emph{Jitter} -- The variations in time delay is called jitter.
        For instance, when transmitting data over a network, if the latency (time delay) is constant in time, there is no jitter.
        Instead, if the latency varies over time (as it usually does), there exists jitter in the system.
        The jitter intensity depends on the size of the latency fluctuations.

    \item \emph{Communication losses} -- If data packets transmitted over a network are lost along their route or too delayed to be useful, they are considered \emph{lost}.
        Another case when the packets are dropped is when the network is shut down or overloaded, either by too much traffic or an attack.
        The packet loss can occur both on the way to and from the hardware.
\end{itemize}
%
Conceptually, it might be natural to view some of the timing irregularities as equivalent from a system perspective.
However, the different models hold unique information about the system that does not necessarily overlap.
It is therefore crucial to analyse all the appropriate models for the specific systems.

This thesis specifically targets systems subject to computational overruns, and to a minor extent also communication losses.
Of particular interest are the problems that occur in real-time control systems due to control tasks overrunning their corresponding deadlines.
It is convenient to blame computational overruns on poor system design and programming errors; however, even a flawless system design can experience overruns due to, for instance, cache memory misses~\addref{} or alpha-induced faults~\addref{}.
More commonly, it is known that the real-time control system's nominal performance is degraded if a design that completely mitigates overruns is used.
Thus, with the awareness that it can cause transient faults, the system engineers tolerate a few overruns when the control task's execution time is near its worst case, in order to improve the system's nominal performance.



\section{Outline}%
\label{sec:intro:outline}%
%
This thesis is written as a collection of papers where the first three chapters serves as both a summary and an extension of the motivation presented in the second part of this thesis, namely the papers comprising the major contribution.
The first chapter presented a high-level introduction to the relevant concepts and problems.
Next, Chapter~\ref{ch:background} provide a rigorous presentation of the concepts that were loosely introduced in Chapter~\ref{ch:intro}.
In addition to the proper problem description, the chapter also outlines the relevant background and related work from both the real-time and control theoretical domains.
For each of the five papers constituting the main part of the thesis, Chapter~\ref{ch:contribution} contains a short summary of its content, a brief description of its scientific contribution, and the respective authors' individual contribution.
The thesis is finally concluded by Papers I-V.
