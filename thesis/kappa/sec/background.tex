\chapter{Background}%
\label{ch:background}%

This chapter presents the necessary background and motivation for the remainder of the thesis.
We divide the chapter in two primary parts.
First, a discussion on the real-time theoretical aspects is provided.
An extended introduction to how real-time operating systems operates is presented, e.g., processor sharing, task states, scheduling strategies, etc.
However, the main focus is dedicated to the most commonly used task models and their respective advantages and disadvantages, with respect to deadline overruns.
Additionally, we provide a brief discussion on state-machine applicability to the aforementioned task models. 
Next, the relevant control theoretical background is presented based on the theory of real-time systems.
Two different system modelling approaches are introduced: switching systems and Markov jump linear systems.
Both models are particularly relevant for real-time systems where the control task can overrun its deadlines.
Specifically for these systems, we present and discuss different stability and performance analyses.

\section{Real-Time Systems}%
\label{sec:background:rts}%
%
% A short extension to the RTS (and RTOS) precise objective
We begin with an introduction to real-time system fundamentals. 
The breadth of the topic prevents a comprehensive review of the existing literature to fit within the scope of this thesis.
In fact, real-time systems are all information processing systems which reacts to external input within a predetermined deadline. 
This includes sensors, actuators, process control, machine vision, robotics, and health care systems, to acknowledge a fraction of all real-time systems.
Instead, we focus the attention to the elements which impact real-time control systems the most, i.e., RTOS fundamentals, periodic tasks, task models, scheduling policies, and execution models.
\question%
{
    Maybe the ``RTOS fundamentals'' should be ``CPU provisioning'' and ``memory management'' instead?
}{}
Since the RTOS is tightly interconnected with the hardware, it is natural to illustrate them jointly.
In Figure~\ref{fig:operating-system-abstraction}, the underlying hardware and real-time structure is expanded.
%
\begin{figure}[t]
    \centering
    \input{\figdir/operating-system-abstraction}%
    \caption{\fix{Need to arrange figure so it makes more sense.}}%
    \label{fig:operating-system-abstraction}%
\end{figure}

% CPU and cores
The \emph{central processing unit} (CPU, or simply \emph{processor}) is the electronic component responsible for executing the task functions.
Each function (or program) is translated into a list of instructions to be executed on the CPU.
These instructions belong to the machine's language used to tell the processor what type of operation to execute, e.g., load a specific memory registry or execute an arithmetic operation.
To execute the program instructions, the processor can contain one or more \emph{cores}, respectively denoting the processor as \emph{single-core} or \emph{multi-core}.
Each core is able to execute a list of program instructions.
Hence, the advantage of using multi-core processors (compared to single-core processors) is the increased number of instructions that can be executed in parallel. 
However, this gain comes at the cost of an elevated system complexity where the memory and application layout has to be adapted to the multi-core architecture~\cite{Brandenburg:2011}.
\question{mention something about ``\#hardware threads = \#cores'' here?}{}

% Memory
Integrated with the processor is a \emph{cache} memory, i.e., a small but fast memory that is easy to access from the operational cores.
The cache memory stores recently accessed instructions and data to reduce the latency induced by fetching from \emph{main memory}, i.e., the main hardware storage.
Most modern CPUs have a layered cache memory hierarchy, where the smallest and fastest layer is denoted L1, the second smallest and fastest is denoted L2, and so on.
When the processor needs to access some data, it first examines whether the data exists in the cache and in that case fetch it from there; otherwise, it collects the data from the main memory.

If a task wants to access cached data (or instructions) that cannot be found, it is said to experience a \emph{cache miss}; similarly, a \emph{cache hit} occurs when the sought data is found in the cache.
Cache misses can arise if
%
\begin{itemize}
    \item the size of the requested data is too large to fetch;
    \item the requested data is not yet loaded into the cache; or
    \item the data have been evicted from the cache, e.g., to make room for more recently retrieved data or from the cache being flushed due to security reasons.
\end{itemize}
%
Ideally, the number of cache misses that a task experiences are kept to a minimum, in particular since fetching data from the main memory can incur large timing overheads on the task execution.
Additionally, the longer a task executes, the less likely it is to contract cache misses.
Intuitively, the task will experience a few initial cache misses when the data is loaded into the cache, but thereafter the cache will be occupied by relevant data and the cache misses should decrease.
This is also known as \emph{cache warming}.
If the task continues to experience significant cache misses even after the cache warming phase, it is said to be \emph{thrashing} the cache, i.e., continuously experience cache misses.
Thrashing can severely impact both real-time performance, energy consumption, and even collapse the execution~\cite{Wadleigh:2000}.
In multi-core setups where different cores share a level-X cache, thrashing is a big concern; however, there exists mitigation strategies~\cite{Brandenburg:2011}.

% GPIO 
To interface with the external environment, the hardware contains \emph{input/output peripherals} (abbreviated \emph{I/O}).
The peripherals are all external components connected to the hardware, e.g., sensors or actuators.
Depending on the hardware, the peripherals can either be connected to the circuit board responsible for joining the different components together or directly into the CPU.
Typically, each peripheral is assigned to a \emph{port} number in the device, i.e., an address to know from where to read or send data. 
The port is then used by the tasks to identify the specific peripheral to use.
If the link to the external environment is wireless, the I/O peripherals are not necessarily sensors or actuators, but rather radio antennas, Bluetooth transmitters, or Wi-Fi routers (depending on the wireless communication protocol) interacting with the sensors and actuators.
\question%
{Mention something about how to translate the data flow to messages?}%
{}%



% Microcontrollers and embedded systems
Although this thesis does not discern different hardware architectures from one another, it is convenient to talk about \emph{microcontrollers}, in particular because of their growing recognition. 
\nv{Continue talking about microcontrollers and embedded systems}

% RTOS, threads

% Tasks (Task stats, and states)

% Scheduler (how it allocates resources), threads, mechanisms, deadline handling, many paragraphs here probably


\nv{Maybe create a figure with different task states?}

\subsection{Execution Modelling using State Machines}%
\label{sec:background:fsm}%
%


\section{Control Systems}%
\label{sec:background:ctrl}%
%

\subsection{Control System Stability}%
\label{sec:background:stability}%
%

\subsection{Control System Performance}%
\label{sec:background:performance}%
%


\nv{%

\section*{Embedded real-time control Systems}%
%
\begin{itemize}
    \item Refer to figure from Chapter~\ref{ch:intro} and then ``zoom'' in on the
        different aspects treated in the different subsections.
    \item Simple description of hardware components: Plant, Sensors, Network
        (wired/wireless), control hardware, actuators.
    \item Simple description of software components: network protocol, RTOS,
        tasks, memory, interrupts, etc.
    \item Maybe create a simple practical example (e.g., taxi of a plane) that
        can be followed throughout this section.
\end{itemize}


\subsection*{Real-Time Model}%
%
\begin{itemize}
    \item Start with a historical perspective
    \item Hard, Soft, Weakly-Hard, More expressive (\cite{Stigge:2011}), other?
    \item Describe advantages and disadvantages with each of the models
    \item recall great example of real-time system in rust book
\end{itemize}

\subsubsection*{Modelling Execution using finite state-machine}%
%
\begin{itemize}
    \item This section should maybe be moved?
    \item Entire subsubsection requested by KE
    \item More automata theory
    \item "typically in control fsm have been used to design highlevel control
        (e.g., taxi takeoff and landing), in principle (computer science)
        automata have been used to represent more complicated things (for
        instance regular languages). This is the basis of what the WeaklyHard.jl
        does."
    \item Include markov theory here. "In CS when the transition was
        non-deterministic, i.e., probabilistic, then you have the concept of
        Markov chains."
\end{itemize}


\subsection*{Control System Model}%
%
\begin{itemize}
    \item Start from plant, non-linear model, linearisation
    \item Sensors and actuator models included here.
    \item Control model (non-linear, more common ones), relate to real-time
        tasks
    \item Switching systems! Markov Jump Linear Systems!
\end{itemize}


\subsubsection*{Stability Analysis}%
%
\begin{itemize}
    \item Binary: Stable or not
    \item Stability definitions: nominal, MS, MSS, JSR, Lyapunov
    \item differences (e.g., JSR vs. Lyapunov), applicability
\end{itemize}


\subsubsection*{Performance Analysis}%
%
\begin{itemize}
    \item Gradient: varying degree of performance
    \item Why Performance Analysis?
    \item Metrics
\end{itemize}

}%


% MENTION SOMETHING ABOUT {SYNCHRONOUS, ASYNCHRONOUS, PERIODIC, APERIODIC} TASKS

% MENTION TASK STATES (INTERNAL AND EXTERNAL)
