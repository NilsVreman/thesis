Robustness is an essential concern in the design of control systems; they must be able to reliably handle nonlinear effects, unmodeled dynamics and noise, as well as delays in signal transmissions and dropped packets.
A lesser known problem concerns the assessment of robustness to \emph{computational issues} when controllers are implemented as periodic tasks in cheap embedded platforms.
Such tasks are expected to execute with real-time guarantees, i.e., their execution must be completed before a well-defined \emph{deadline}, when the control output must be sent to the actuator.
However, it is common in practice~\cite{akesson2020empirical} that tasks do not always complete within their deadline, causing what is called a \emph{deadline miss}.
This may be caused by delays in computation and memory accesses, transient overloads, bugs and other issues.

A popular model to describe real-time systems allowing deadline misses is the \emph{weakly-hard} model~\cite{Bernat:2001}. 
Weakly-hard tasks feature constraints defining a maximum number of deadlines that can be missed (alternatively, a minimum number to be satisfied) in a given number of consecutive periods.
This model is also the focus of this work.
To analyse the effects on the controlled plant, it is necessary to specify also \emph{what happens when the miss is experienced}, both in terms of changes to the control signal and of actions taken to deal with the failed computation~\cite{Pazzaglia:2019}.
An instance that experiences a deadline miss can be allowed to continue executing until completion (and possibly used later), while in other applications it is stopped and discarded instead.

There is however a mismatch between the guarantees that can be obtained for real-time tasks and platforms~\cite{Ernst:2015,choi2019job}, and the analysis available for \emph{control} tasks under the weakly-hard model.
Fewer works deal with \emph{stability} analysis of weakly-hard real-time control tasks, often targeting specific use-cases. 
For instance, the analysis in~\cite{Maggio:2020} is limited to constraints specifying a maximum number of \emph{consecutive} deadline misses.
The results in \cite{Linsenmayer:2017,linsenmayer2020linear}, obtained for networked linear control systems having packet dropouts bounded using the weakly-hard model, can not be generalised for \emph{late completions} or \emph{sets} of weakly-hard constraints.
The authors of~\cite{liang2019security,liang2020leveraging} studied safety guarantees of weakly-hard controllers, considering a miss as a discarded computation with a known periodic pattern.
In \cite{huang2020saw, huang2019formal}, an over-approximation-based approach is proposed to check the safety of nonlinear weakly-hard systems, where misses are treated as discarded computations and the actuator holds its previous value.
Convergence rates (providing sufficient stability guarantees) are analysed in~\cite{Gaukler:2019a}.
A Lyapunov-based stability analysis of nonlinear weakly-hard systems is studied in~\cite{hertneck2021efficient}, with deadline misses treated as packet dropouts.
However, the state-of-the-art listed above lack generalisability to more expressive real-time implementations, such as different deadline miss models or handling strategies.

This paper aims at filling the gap, by providing a stability analysis that can be applied to a class of generic weakly-hard models and deadline miss handling strategies.
More precisely:
\begin{enumerate}[label=(\roman*)]
    \item We formally extend the weakly-hard model to explicitly consider the strategy used to handle the miss events. 
    \item By leveraging an automaton representation of the sequences allowed by (a set of) extended weakly-hard constraints, we use Kronecker lifting and the joint spectral radius to properly express its stability conditions.
    \item Using the concept of constraint dominance, we prove analytic bounds on the stability of a weakly-hard system with respect to \emph{less dominant} constraints.
\end{enumerate}
Finally, we analyse the stability of the resulting closed-loop systems using \code{SparseJSR}~\cite{sparsejsr}, which exploits the sparsity pattern that naturally arises in the Kronecker lifted representation.
The proposed analysis calls for modularity and separation of concern, and can be a useful tool to decouple the constraint specification and the control verification.

%, the embedded system designer can extract a set of constraints to be used in the design phase, and the control engineer can verify that the proposed constraints satisfy all control requirements. 
%Robustness is an essential concern in the design of control systems~\cite{Zhou:1998}.
%Robust control design techniques ensure that controlled systems are able to reliably handle nonlinear effects, unmodeled dynamics, and external noise.
%Distributed controllers were also demonstrated to be robust to problems that may occur in the communication network, like data loss for either the sensor measurement or the control signals~\cite{Lemmon:2002, Lemmon:2003b, Heemels:2015, Heemels:2016b, Heemels:2018}, or aperiodic behaviour~\cite{al2017stability}.
%However, the vast majority of the literature dealing with control systems' robustness to implementation issues in fact deals with delays in the transmission and dropped packets.
%On the contrary, this paper addresses the problem of sampled controllers' robustness to \emph{computational issues}.
%This latter aspect is relevant for a vast number of control applications, which rely on the usage of digital controllers implemented as periodic \emph{tasks} in cheap embedded platforms.
%Such tasks are expected to execute with real-time guarantees, and that their execution must be completed before a well-defined \emph{deadline}, usually corresponding to the activation of the next periodic instance of the task.
%
%In the case of a digital controller, its execution consists in performing the control signal calculation and dealing with sensing and actuation.
%In practice, control systems are often designed introducing one step delay: this helps masking the timing variability experienced using embedded platforms, that often have to dynamically share their limited computational resources among many concurrent functions.
%It is still possible -- and it happens quite often in practice~\cite{akesson2020empirical} -- that tasks do not complete within their execution period, causing what is called a \emph{deadline miss}.
%The reasons behind misses can vary, from delays to non-delivered sensor messages, to transient overload conditions, to bugs in the controller code.
%
%Generally speaking, extensive studies have been made about real-time systems that allow deadline misses, and two main frameworks arose: soft real-time tasks~\cite{buttazzo2005soft} and weakly-hard tasks~\cite{Bernat:2001}.
%The first model is often used for those tasks where completing the execution before the deadline is beneficial, but not strictly required all the time.
%It is in general associated with a \emph{probabilistic} description of deadline misses~\cite{fontanelli2013continuous,Heemels:2016a,Jiang:2016,kim2005exact}, and with the definition of a performance loss function for late completions.
%Due to its probabilistic nature, this approach has mostly been used to describe multimedia applications~\cite{Cucinotta:2010}, like video encoding and decoding, in which a small delay is not perceived by the end user, as long as it does not happen too frequently.
%Nonetheless, the soft deadline model has been applied in the past also for the case of control tasks design with some success, e.g., in~\cite{caccamo2002handling, cervin2005control, fontanelli2013soft,fontanelli2013continuous, fontanelli2015optimal}.
%The second model -- weakly-hard tasks -- applies to those cases where it is important to identify worst-case conditions. 
%Weakly-hard tasks are characterized by a maximum number of deadlines that can be missed in a given number of consecutive periods. 
%This can be defined, e.g., by a constraint of the form $(m, k)$ to describe a task that cannot miss more than $m$ deadlines in every $k$ consecutive activations.
%The weakly-hard model has gained a lot of traction recently, especially in the real-time community. 
%Its properties have also been studied for control tasks that occasionally miss deadlines~\cite{ramanathan1999overload, Frehse:2014, Pazzaglia:2018, Maggio:2020}, and will also be the focus of this work.
%
%Assessing properties of control systems that miss deadlines is not only important for the embedded systems architects, but it is also an important research area in the control domain~\cite{Cervin:2005, Linsenmayer:2017, Chakraborty:2018, pazzaglia2021adaptive}.
%When considering a \emph{control task}, to properly analyse the effect a miss has on the controlled plant, it is necessary to specify also \emph{what happens when the miss is experienced}, both in terms of changes to the control signal and in terms of actions taken to deal with the failed task~\cite{Pazzaglia:2019}.
%In the case of embedded controllers, different approaches are used. 
%For example, a computation instance that experiences a deadline miss can be allowed to continue executing until completion (and possibly used later), while in other applications it is stopped and discarded instead.
%
%There is however quite a mismatch between the guarantees that can be obtained for real-time tasks and platforms~\cite{Hammadeh:2017b, Hammadeh:2019, choi2019job, pazzaglia2020generalized}, and the analysis that is available for \emph{control} tasks~\cite{Pazzaglia:2018, Maggio:2020}.
%In particular, fewer works deal with the \emph{stability} analysis of real-time control tasks subject to weakly-hard deadline misses, and they often lack generality. 
%The analysis presented in~\cite{Maggio:2020} (which can be considered the closest work to this paper) is limited to constraints that specify a maximum number of \emph{consecutive} deadline misses.
%The majority of other state-of-the-art approaches deal with constraints of the form $(m,k)$.
%In particular, the works in \cite{Linsenmayer:2017} and \cite{linsenmayer2020linear} study the stability of \emph{networked control systems} where packet dropouts (or system faults) are bounded using the $(m,k)$ constraint model.
%This model is equivalent to the case where deadline misses represent discarded computations, but its results can not be generalized for the other common case of \emph{late completions}.
%In other works~\cite{huang2019exploring,liang2019security,liang2020leveraging}, the authors have studied how to enforce safety guarantees of weakly-hard real-time controllers, with focus also on stability. However, they consider only the case where a deadline miss corresponds to a discarded computation, with the additional hypothesis of a known periodic pattern of deadline hits and misses~\cite{liang2019security,liang2020leveraging}.
%
%This paper aims at filling this gap, by providing a stability analysis that can be applied to a general class of weakly-hard models and strategies at the deadline miss event.
%To the best of our knowledge, the analysis proposed in this paper is also the first being able to guarantee the stability of systems subject to \emph{multiple} constraints belonging to \emph{any} of the weakly-hard types available in the state-of-the-art.
%More precisely:
%\begin{enumerate}[label=(\roman*)]
%    \item The paper formally extends the weakly-hard model to explicitly consider the strategy used to handle computational problems that result in miss events (which was only intuitively introduced in some prior work).
%    \item It builds a representation of the control task execution, subject to a set of weakly-hard constraints as an automaton. We use the resulting automaton to construct a transition matrix that determines the valid transitions.
%    \item It uses Kronecker lifting and the joint spectral radius as tools to properly express stability conditions for systems that satisfy a set of weakly-hard constraints.
%    \item It uses the concept of constraint dominance to prove analytic bounds on the stability of a weakly-hard system with respect to \emph{less dominant} weakly-hard constraints.
%    \item It analyses the stability of the resulting closed-loop systems using \texttt{SparseJSR}, an algorithm that exploits the sparsity pattern that naturally arises in the Kronecker lifted representation of the closed-loop systems.
%\end{enumerate}
%
%The analysis presented in this paper calls for modularity and separation of concern, by decoupling the constraint specification and the control verification. 
%With the proposed method, the embedded system designer can extract a set of constraints that belong to the hardware and software design phase and the control engineer can verify that the proposed constraints satisfy all control requirements. 
